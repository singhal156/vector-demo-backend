"use strict";
//
// Copyright 2024 Picovoice Inc.
//
// You may not use this file except in compliance with the license. A copy of the license is located in the "LICENSE"
// file accompanying this source.
//
// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
// an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const assert = require("assert");
const pv_status_t_1 = require("./pv_status_t");
const errors_1 = require("./errors");
const platforms_1 = require("./platforms");
/**
 * Node.js binding for Cobra voice activity detection engine
 *
 * Performs the calls to the Cobra node library. Does some basic parameter validation to prevent
 * errors occurring in the library layer. Provides clearer error messages in native JavaScript.
 */
class Cobra {
    _pvCobra;
    _handle;
    _version;
    _frameLength;
    _sampleRate;
    /**
     * Creates an instance of Cobra.
     * @param {string} accessKey AccessKey obtained from Picovoice Console (https://console.picovoice.ai/).
     * @param options Optional configuration arguments.
     * @param {string} options.libraryPath the path to the Cobra library (.node extension)
     */
    constructor(accessKey, options = {}) {
        assert(typeof accessKey === 'string');
        if (accessKey === null ||
            accessKey === undefined ||
            accessKey.length === 0) {
            throw new errors_1.CobraInvalidArgumentError(`No AccessKey provided to Cobra`);
        }
        const { libraryPath = (0, platforms_1.getSystemLibraryPath)() } = options;
        if (!fs.existsSync(libraryPath)) {
            throw new errors_1.CobraInvalidArgumentError(`File not found at 'libraryPath': ${libraryPath}`);
        }
        const pvCobra = require(libraryPath); // eslint-disable-line
        this._pvCobra = pvCobra;
        let cobraHandleAndStatus = null;
        try {
            pvCobra.set_sdk('nodejs');
            cobraHandleAndStatus = pvCobra.init(accessKey);
        }
        catch (err) {
            (0, errors_1.pvStatusToException)(pv_status_t_1.default[err.code], err);
        }
        const status = cobraHandleAndStatus.status;
        if (status !== pv_status_t_1.default.SUCCESS) {
            this.handlePvStatus(status, 'Cobra failed to initialize');
        }
        this._handle = cobraHandleAndStatus.handle;
        this._sampleRate = pvCobra.sample_rate();
        this._frameLength = pvCobra.frame_length();
        this._version = pvCobra.version();
    }
    /**
     * @returns number of audio samples per frame (i.e. the length of the array provided to the process function)
     * @see {@link process}
     */
    get frameLength() {
        return this._frameLength;
    }
    /**
     * @returns the audio sampling rate accepted by the process function
     * @see {@link process}
     */
    get sampleRate() {
        return this._sampleRate;
    }
    /**
     * @returns the version of the Cobra engine
     */
    get version() {
        return this._version;
    }
    /**
     * Processes a frame of audio and returns the voice probability result.
     *
     * @param {Int16Array} pcm Audio data. The audio needs to have a sample rate equal to `Cobra.sampleRate` and be 16-bit linearly-encoded.
     * The specific array length can be attained by calling `Cobra.frameLength`. This function operates on single-channel audio.
     * @returns {number} Probability of voice activity. It is a floating-point number within [0, 1].
     */
    process(pcm) {
        assert(pcm instanceof Int16Array);
        if (this._handle === 0 ||
            this._handle === null ||
            this._handle === undefined) {
            throw new errors_1.CobraInvalidStateError('Cobra is not initialized');
        }
        if (pcm === undefined || pcm === null) {
            throw new errors_1.CobraInvalidArgumentError(`PCM array provided to 'Cobra.process()' is undefined or null`);
        }
        else if (pcm.length !== this.frameLength) {
            throw new errors_1.CobraInvalidArgumentError(`Size of frame array provided to 'Cobra.process()' (${pcm.length}) does not match the engine 'Cobra.frameLength' (${this.frameLength})`);
        }
        let voiceProbabilityAndStatus = null;
        try {
            voiceProbabilityAndStatus = this._pvCobra.process(this._handle, pcm);
        }
        catch (err) {
            (0, errors_1.pvStatusToException)(pv_status_t_1.default[err.code], err);
        }
        const status = voiceProbabilityAndStatus.status;
        if (status !== pv_status_t_1.default.SUCCESS) {
            this.handlePvStatus(status, 'Cobra failed to process the audio frame');
        }
        return voiceProbabilityAndStatus.is_voiced;
    }
    /**
     * Releases the resources acquired by Cobra.
     *
     * Be sure to call this when finished with the instance
     * to reclaim the memory that was allocated by the C library.
     */
    release() {
        if (this._handle !== 0) {
            this._pvCobra.delete(this._handle);
            this._handle = 0;
        }
    }
    handlePvStatus(status, message) {
        const errorObject = this._pvCobra.get_error_stack();
        if (errorObject.status === pv_status_t_1.default.SUCCESS) {
            (0, errors_1.pvStatusToException)(status, message, errorObject.message_stack);
        }
        else {
            (0, errors_1.pvStatusToException)(status, 'Unable to get Cobra error state');
        }
    }
}
exports.default = Cobra;
//# sourceMappingURL=cobra.js.map